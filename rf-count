#!/usr/bin/env perl

use strict;
use File::Basename;
use File::Copy;
use File::Path qw(mkpath);
use File::Spec;
use FindBin qw($Bin);
use Fcntl qw(:flock SEEK_SET SEEK_END);
use Getopt::Long qw(:config no_ignore_case);

use lib $Bin . "/lib";

use Core::Utils;
use Core::Mathematics qw(:all);
use Core::Process::Queue;
use Core::Statistics;
use Data::IO::Sequence;
use Data::Sequence::Utils;
use Graphics::Chart::Barplot;
use Graphics::Image;
use RF::Data::RC;
use RF::Data::IO::MM;
use RF::Data::IO::RC;
use RF::Utils;
use Term::Progress;
use Term::Progress::Multiple;
use Term::Table;
use Term::Utils;

$|++;

my ($tmpdir, $output, $wt, $samtoolsParams,
    $samtools, $multifasta, $sam, $help, 
    $overwrite, $error, $bam_trim5, $offset, 
    $threads, $processmanager, $mbfile, $table, 
    $mutcount, $seqio, $rcio, $includeclip, 
    $covonly, $mutmap, $nodel, $pp, $po, $tsPerJob,
    $nodiscarddup, $minqual, $maxdel, $maxmut, 
    $hashead, $progressBar, $mapqual, $noambiguous, 
    $medianqual, $noins, $collapse, $maxmutdist, 
    $evalsurround, $leftalign, $discardshorter, $leftdel, 
    $rightdel, $rmconsecutive, $maxcov, $primaryonly, 
    $whitelist, $onlyMut, $noCovLowQual, $outRawCounts, 
    $fast, $multiBar, $image, $R, @mutClasses, 
    @bam_trim5, @ids, @qcounter, @stats, %transcripts, 
    %spacer, %files, %masks, %realid, %onlyMut, %allStats, 
    %allFreqs);

do {

    local $SIG{__WARN__} = sub { };

    GetOptions( "h|help"                     => \$help,
                "a|fast"                     => \$fast,
                "o|output-dir=s"             => \$output,
                "ow|overwrite"               => \$overwrite,
                "t5|trim-5prime=s"           => \$bam_trim5,
                "wt|working-threads=i"       => \$wt,
                "s|samtools=s"               => \$samtools,
                "p|processors=i"             => \$threads,
                "f|fasta=s"                  => \$multifasta,
                "m|count-mutations"          => \$mutcount,
                "orc|out-raw-counts"         => \$outRawCounts,
                "mf|mask-file=s"             => \$mbfile,
                "ic|include-clipped"         => \$includeclip,
                "co|coverage-only"           => \$covonly,
                "nd|no-deletions"            => \$nodel,
                "ni|no-insertions"           => \$noins,
                "md|max-deletion-len=i"      => \$maxdel,
                "pp|properly-paired"         => \$pp,
                "po|paired-only"             => \$po,
                "q|min-quality=i"            => \$minqual,
                "mq|map-quality=i"           => \$mapqual,
                "me|max-edit-distance=s"     => \$maxmut,
                "na|no-ambiguous"            => \$noambiguous,
                "la|left-align"              => \$leftalign,
                "eq|median-quality=i"        => \$medianqual,
                "cc|collapse-consecutive"    => \$collapse,
                "mc|max-collapse-distance=i" => \$maxmutdist,
                "es|eval-surrounding"        => \$evalsurround,
                "ds|discard-shorter=i"       => \$discardshorter,
                "mm|mutation-map"            => \$mutmap,
                "ld|left-deletion"           => \$leftdel,
                "rd|right-deletion"          => \$rightdel,
                "dc|discard-consecutive=i"   => \$rmconsecutive,
                "mv|max-coverage=i"          => \$maxcov,
                "pn|primary-only"            => \$primaryonly,
                "wl|whitelist=i"             => \$whitelist,
                "om|only-mut=s"              => \$onlyMut,
                "ndd|no-discard-duplicates"  => \$nodiscarddup,
                "ncl|no-cov-low-qual"        => \$noCovLowQual,
                "P|per-file-progress"        => \$multiBar,
                "g|img"                      => \$image,
                "R|R-path=s"                 => \$R ) or help(1);

};

help() if ($help);

# Default values
$output ||= "rf_count/";
$wt ||= 1;
$offset = 0;
$threads ||= 1;
$bam_trim5 //= 0;
$minqual //= 20;
$medianqual //= 20;
$mapqual //= 10;
$maxdel //= 10;
$maxmutdist //= 2;
$maxmut ||= 0.15;
$discardshorter //= 1;
$rmconsecutive //= 0;
$samtools ||= which("samtools");
$R = checkRinstall($R) if ($image && !$covonly);
@mutClasses = qw(AC AG AT CA CG CT GA GC GT TA TC TG ins del);

$output =~ s/\/?$/\//;
$tmpdir = $output . "tmp/";
$multiBar = 0 if (!-t STDOUT);

##
# Input validation
##

die "\n  [!] Error: No sample SAM/BAM file provided\n\n" if (!@ARGV);
die "\n  [!] Error: No FASTA file provided\n\n" if (!defined $multifasta);
die "\n  [!] Error: Provided FASTA file doesn't exist\n\n" if (!-e $multifasta);
die "\n  [!] Error: Provided mask file doesn't exist\n\n" if (defined $mbfile && !-e $mbfile);
die "\n  [!] Error: Parameters -co and -m are mutually exclusive\n\n" if ($mutcount && $covonly);
die "\n  [!] Error: Working threads value must be an integer greater than 0\n\n" if (!isint($wt) || $wt < 1);
die "\n  [!] Error: Invalid format for -t5 parameter's argument\n\n" if (defined $bam_trim5 && $bam_trim5 !~ m/^(\d+[;,]?)+$/);
die "\n  [!] Error: Number of processors must be an integer greater than 0\n\n" if ($threads < 1);
die "\n  [!] Error: Minimum quality score value must be and integer >= 0 and <= 41\n\n" if (!inrange($minqual, [0, 41]));
die "\n  [!] Error: Median read's quality score value must be and integer >= 0 and <= 41\n\n" if (!inrange($medianqual, [0, 41]));
die "\n  [!] Error: Maximum edit distance value must be > 0 and <= 1\n\n" if (!inrange($maxmut, [0, 1]) || !$maxmut);
die "\n  [!] Error: Parameters -na and -la are mutually exclusive\n\n" if ($noambiguous && $leftalign);
die "\n  [!] Error: Parameters -cc and -dc are mutually exclusive\n\n" if ($collapse && $rmconsecutive);
die "\n  [!] Error: Max coverage must be >= 1000\n\n" if (defined $maxcov && $maxcov < 1000);
die "\n  [!] Error: Parameter -mv requires parameter -m\n\n" if ($maxcov && !$mutcount);
die "\n  [!] Error: Parameter -mm requires parameter -m\n\n" if ($mutmap && !$mutcount);
die "\n  [!] Error: Parameter -nd requires parameter -m\n\n" if ($nodel && !$mutcount);
die "\n  [!] Error: Parameter -orc requires parameter -m\n\n" if ($outRawCounts && !$mutcount);
die "\n  [!] Error: Parameter -om requires parameter -m\n\n" if ($onlyMut && !$mutcount);
die "\n  [!] Error: Whitelist must be an integer > 0\n\n" if (defined $whitelist && $whitelist < 1 && $mutcount);
die "\n  [!] Error: Discard shorter must be either \"MEDIAN\" or > 0\n\n" if (defined $discardshorter &&
                                                                              ((isint($discardshorter) && $discardshorter < 1) &&
                                                                               $discardshorter !~ m/^median$/i));
warn "\n  [!] Warning: Some input files are duplicates. Considering only unique files...\n" if (@ARGV != uniq(@ARGV));

if ($image && $covonly) {

    print "\n  [i] Note: No plot will be generated in -co (--coverage-only) mode...\n";
    undef($image);

}

if ($mutcount && $onlyMut) {

    # Automatically disables counting indels
    $nodel = 1;
    $noins = 1;

    %onlyMut = map { my $i = $_; map { $i . $_ => { count => 0,
                                                    take  => 0 } } qw(A C G T) } qw(A C G T);

    foreach my $mutation (split(/[,;]/, $onlyMut)) {

        my @bases = split(/[:2>]/, $mutation);

        die "\n  [!] Error: Invalid format for -mo parameter's argument \"" . $mutation . "\"\n\n" if (@bases != 2);
        die "\n  [!] Error: Mutation in -mo parameter's argument \"" . $mutation . "\" contains a non-IUPAC character\n\n" if (!isiupac(join("", @bases)));

        foreach my $base1 (split //, (iupac2nt($bases[0]))[0]) {

            foreach my $base2 (split //, (iupac2nt($bases[1]))[0]) { $onlyMut{$base1 . $base2}->{take} = 1; }

        }

    }

}

if (!defined $samtools) { die "\n  [!] Error: samtools is not in PATH\n\n"; }
elsif (!-e $samtools) { die "\n  [!] Error: samtools does not exist\n\n"; }
elsif (!-x $samtools) { die "\n  [!] Error: samtools is not executable\n\n"; }
else {

    my $ret = `$samtools 2>&1`;

    if ($ret =~ m/Version: ([\d\.]+)/) {

        my $version = $1;

        die "\n  [!] Error: RF Count requires SAMTools v1 or greater (Detected: v" . $version . ")\n\n" if (substr($version, 0, 1) < 1);

    }
    else { warn "\n  [!] Warning: Unable to detect SAMTools version\n"; }

    my (@noFlags, @yesFlags);
    @noFlags = qw(UNMAP QCFAIL);
    push(@yesFlags, "PAIRED") if ($pp || $po);
    push(@yesFlags, "PROPER_PAIR") if ($pp);
    push(@noFlags, "REVERSE") if (!$mutcount && !$covonly);
    push(@noFlags, "SECONDARY") if ($primaryonly);
    push(@noFlags, "DUP") if (!$nodiscarddup);

    $samtoolsParams = "-f " . join(",", uniq(@yesFlags)) . " " if (@yesFlags);
    $samtoolsParams = "-F " . join(",", uniq(@noFlags)) . " -q $mapqual";

}

#$SIG{__DIE__} = \&cleanup;

print "\n[+] Making output directory...";

if (-e $output) {

    if ($overwrite) {

        my $error = rmtree($output);

        die "\n\n  [!] Error: " . $error . "\n\n" if ($error);

    }
    else { die "\n\n  [!] Error: Output directory already exists." .
               "\n      Please use -ow (or --overwrite) to overwrite output directory\n\n"; }

}

mkpath($tmpdir, { mode  => 0755,
                  error => \$error });

die "\n\n  [!] Error: Unable to create output directory (" . $error->[0]->{each(%{$error->[0]})} . ")\n\n" if (@{$error});

mkpath($output . "whitelists/", { mode  => 0755,
                                  error => \$error }) if ($whitelist);

if ($mutcount) {

    mkpath($output . "frequencies/", { mode  => 0755,
                                    error => \$error }) if ($onlyMut);
    mkpath($output . "raw_counts/", { mode  => 0755,
                                    error => \$error }) if ($outRawCounts);

}

mkpath($output . "plots/", { mode  => 0755,
                             error => \$error }) if ($image);

##
# Prepare files
##

$table = Term::Table->new(indent => 2);
$table->head("Sample", "File format", "Sorted", "Indexed", "5'-end trimming");

@bam_trim5 = split(/,/, $bam_trim5);

undef($bam_trim5);
$bam_trim5 = shift(@bam_trim5) if (@bam_trim5 == 1);        # If only one value for 5' trimming in SAM/BAM files has been specified,
                                                            # this is applied to all the passed SAM/BAM files

print "\n[+] Checking files:\n\n";

foreach my $sample (uniq(@ARGV)) {

    die "  [!] Error: Specified sample file \"$sample\" doesn't exist\n\n" if (!-e $sample);

    my ($file, $path, $extension, $format,
        $sorted);
    ($file, $path, $extension) = fileparse($sample, qr/\.[^.]*/);
    ($format, $sorted) = guessTypeAndSorting($sample);

    push(@qcounter, { path      => $sample,
                      file      => $file,
                      type      => $format,
                      sorted    => $sorted,
                      indexed   => -e "$sample.bai" ? 1 : 0,
                      trim5     => 0 });

    $files{$file} = $#qcounter;
    $spacer{$file} = length($file);

    # If only one value for 5' trimming in SAM/BAM files has been specified, this is applied to all the passed SAM/BAM files
    $qcounter[-1]->{trim5} = isint($bam_trim5) && ispositive($bam_trim5) ? $bam_trim5 : shift(@bam_trim5);

    die "  [!] Error: Fewer 5'-end trimming values in -t5 list than provided SAM/BAM files\n\n" if (!defined $qcounter[-1]->{trim5});
    die "  [!] Error: 5'-end trimming value must be a positive integer\n\n" if (!ispositive($qcounter[-1]->{trim5}) ||
                                                                                !isint($qcounter[-1]->{trim5}));

    $table->row($qcounter[-1]->{file}, $qcounter[-1]->{type}, $sorted ? "Yes" : "No", 
                $qcounter[-1]->{indexed} ? "Yes" : "No", ($mutcount || $covonly) ? "Ignored" : $qcounter[-1]->{trim5} . " nt");

}

%spacer = map { $_ => 1 + max(values %spacer) - $spacer{$_} } (keys %spacer);
$multiBar = 0 if ($multiBar && @qcounter > (termsize())[0]);

die "  [!] Error: More 5'-end trimming values in -t5 list than provided BAM files\n\n" if (@bam_trim5);

$table->print();

print "\n";

# Starts the process manager
$processmanager = Core::Process::Queue->new( processors => $threads,
                                             stderr     => $output . "error.out",
                                             tmpDir     => $tmpdir,
                                             verbosity  => 1 );

##
# FASTA Parsing
##

print "\n[+] Getting transcripts from reference, and building count table base structure...";

$seqio = Data::IO::Sequence->new( file      => $multifasta,
                                  maskIUPAC => 1 );
$rcio = RF::Data::IO::RC->new( file       => $tmpdir . "base.rc",
                               index      => $output . "index.rci",
                               buildindex => 1,
                               mode       => "w" );

while (my $entry = $seqio->read()) {

    $entry->unmask(); # Makes sequence uppercase

    my ($id, $rentry, $offset);
    $id = $entry->id();
    $id =~ s/[^\w\.-]/_/g;    # Fixes sequence ids containing slashes that can cause errors at later stages

    $rentry = RF::Data::RC->new( id       => $id,
                                 sequence => $entry->sequence(),
                                 counts   => [(0) x $entry->length()],
                                 coverage => [(0) x $entry->length()] );
    ($offset) = $rcio->write($rentry);

    # Store length for later steps
    $transcripts{$id} = $fast ? $entry->sequence() : $entry->length();
    $realid{$id} = $entry->id();

}

$rcio->close();

@ids = sort keys %transcripts;
$tsPerJob = max(1, round(@ids / 500));

##
# SAM/BAM Header validation
##

print "\n[+] Inspecting SAM/BAM file headers...\n";

foreach my $sample (@qcounter) {

    my $inheader = 0;

    open(my $fh, "-|", "$samtools view -H " . $sample->{path} . " 2>&1") or die "\n\n  [!] Error: Unable to read SAM/BAM header from sample \"" . $sample->{file} . "\" (" . $! . ")\n\n";

    while (my $row = <$fh>) {

        chomp($row);

        if ($row =~ m/^\@SQ\tSN:(.+?)\tLN:(\d+)/) {

            my ($id, $length) = ($1, $2);
            $id =~ s/\//_/g;

            if (exists $transcripts{$id}) {

                my $trueLen = $fast ? length($transcripts{$id}) : $transcripts{$id};

                die "\n  [!] Error: Transcript \"$id\" length from sample \"" . $sample->{file} . "\" header ($length nt) differs from reference ($trueLen nt)." .
                    "\n             Please re-map your dataset using the same reference, and try again.\n\n" if ($trueLen != $length);

                $inheader++;

            }

        }

    }
    close($fh);

    die "\n  [!] Error: All transcripts in sample \"" . $sample->{file} . "\" header are absent in reference." .
        "\n             Please re-map your dataset using the same reference, or provide a different reference by the -f (or --fasta) parameter.\n\n" if (!$inheader);

    warn "\n  [!] Warning: Only " . $inheader . "/" . keys(%transcripts) . " reference transcripts are present in sample \"" . $sample->{file} . "\" header." .
         "\n               All transcripts absent in reference will be skipped.\n" if ($inheader != keys(%transcripts));

}

##
# Estimate read length (if maxcov is specified)
##

if (($maxcov || $discardshorter =~ m/^median$/i) && $mutcount) {

    print "\n[+] Estimating median read lengths:\n\n";

    foreach my $sample (@qcounter) {

        my @lengths;

        open(my $fh, "-|", "$samtools view $samtoolsParams " . $sample->{path} . " 2>&1") or die "  [!] Error: Unable to read SAM/BAM file for sample \"" . $sample->{file} . "\" (" . $! . ")\n\n";
        while (my $row = <$fh>) {

            chomp($row);
            my @row = split(/\t/, $row);

            push(@lengths, (parsecigar($row[5]))[2]); # The true length (so the number of bases of target covered)

            last if (@lengths == 10000);

        }
        close($fh);

        $sample->{medianReadLen} = round(median(@lengths));

    }

    my $table = Term::Table->new(indent => 2);
    $table->head("Sample", "Median");
    $table->row($_->{file}, $_->{medianReadLen} . " nt") for (@qcounter);
    $table->print();

    print "\n";

}

##
# Sorting BAM files (if needed)
##

if (my @unsorted = grep { !$_->{sorted} } @qcounter) { 

    print "\n[+] Sorting " . scalar(@unsorted) . " unsorted SAM/BAM file(s)...\n";

    $processmanager->onstart(sub { print "\n  [-] Sorting sample \"" . $_[0] . "\"" . (" " x $spacer{$_[0]}) . "(PID: " . $_[1] . ")"; });

    foreach my $sample (@unsorted) {

        my $path = $tmpdir . $sample->{file} . "_sorted.bam";

        $processmanager->enqueue( command => "$samtools sort -@ $wt -O BAM -T \"" . $tmpdir . $sample->{file} . "\" -o \"$path\" \"" . $sample->{path} . "\"",
                                  id      => $sample->{file} );

        $sample->{path} = $path;
        $sample->{type} = "BAM";

    }

    $processmanager->start();
    $processmanager->waitall();

    while (my $sample = $processmanager->dequeue()) { die "\n\n  [!] Error: Unable to sort sample \"" . $sample->id() . "\"\n\n" if ($sample->exitcode()->[0]); }

    print "\n";

}

##
# Converting SAM>BAM files (if needed)
##

if (my @sam = grep { $_->{type} eq "SAM" } @qcounter) { 

    print "\n[+] Converting " . scalar(@sam) . " sorted SAM file(s) to BAM format...\n";

    $processmanager->onstart(sub { print "\n  [-] Converting sample \"" . $_[0] . "\"" . (" " x $spacer{$_[0]}) . "(PID: " . $_[1] . ")"; });

    foreach my $sample (@sam) {

        my $path = $tmpdir . $sample->{file} . ".bam";

        $processmanager->enqueue( command => "$samtools view -@ $wt -O BAM -o \"$path\" \"" . $sample->{path} . "\"",
                                  id      => $sample->{file} );

        $sample->{path} = $path;
        $sample->{type} = "BAM";

    }

    $processmanager->start();
    $processmanager->waitall();

    while (my $sample = $processmanager->dequeue()) { die "\n\n  [!] Error: Unable to convert sample \"" . $sample->id() . "\"\n\n" if ($sample->exitcode()->[0]); }

    print "\n";

}

##
# Indexing BAM files (if needed)
##

if (my @toIndex = grep { !$_->{indexed} } @qcounter) { 

    print "\n[+] Indexing " . scalar(@toIndex) . " BAM file(s)...\n";

    $processmanager->onstart(sub { print "\n  [-] Indexing sample \"" . $_[0] . "\"" . (" " x $spacer{$_[0]}) . "(PID: " . $_[1] . ")"; });

    foreach my $sample (@toIndex) {

        $processmanager->enqueue( command => "$samtools index -@ $wt \"" . $sample->{path} . "\"",
                                  id      => $sample->{file} );

        $sample->{indexed} = 1;

    }

    $processmanager->start();
    $processmanager->waitall();

    while (my $sample = $processmanager->dequeue()) { die "\n\n  [!] Error: Unable to index sample \"" . $sample->id() . "\"\n\n" if ($sample->exitcode()->[0]); }

    print "\n";

}

if (-e $mbfile) {

    my $masked = 0;

    print "\n[+] Applying mask to transcript bases...";

    open(my $mh, "<", $mbfile) or die "\n\n  [!] Error: Unable to read from mask file (" . $! . ")\n\n";
    while(my $line = <$mh>) {

        chomp($line);

        next if ($line =~ m/^\s?#/);

        my @line = split(/[,;]/, $line);
        $line[0] =~ s/\//_/g;

        next if (@line < 2);
        next if (!exists $transcripts{$line[0]});

        foreach my $i (1 .. $#line) {

            my $sequence = uc($seqio->read($line[0])->sequence());
            $line[$i] =~ s/\s//g;

            if ($line[$i] =~ /^(?:rc:)?([ACGTUN]+)$/i) {

                my ($maskSeq, $index);
                $maskSeq = uc($1);
                $maskSeq = dnarevcomp($maskSeq) if ($line[$i] =~ /^rc:/i);
                $line[$i] = rna2dna($maskSeq);
                $index = index($sequence, $line[$i]);

                next if ($index == -1);

                push(@{$masks{$line[0]}}, [$index, $index + length($line[$i]) - 1]);
                $masked++;

            }
            elsif ($line[$i] =~ m/^(\d+)-(\d+)$/) {

                my ($start, $end) = ($1, $2);
                my $trueLen = $fast ? length($transcripts{$line[0]}) : $transcripts{$line[0]};

                next if (!ispositive($start) ||
                         $start > $end ||
                         $start > $trueLen - 1 ||
                         $end > $trueLen - 1);

                push(@{$masks{$line[0]}}, [$start, $end]);
                $masked++;

            }

        }

    }
    close($mh);

    print " [$masked masks applied]";

}

print "\n[+] Copying RC base structure...";

foreach my $sample (@qcounter) {

    die "\n\n  [!] Error: Unable to copy counts table structure for sample \"" . $sample->{file} . "\" (" . $! . ")" unless (copy($tmpdir . "base.rc", $output . $sample->{file} . ".rc"));

}

print "\n[+] Queuing jobs...";

for (my $i = 0; $i < @ids; $i += $tsPerJob) {

    my ($last, @ts);
    $last = min($#ids, $i + $tsPerJob - 1);
    @ts = @ids[$i .. $last]; 

    foreach my $sample (@qcounter) {

        $processmanager->enqueue( command   => \&count,
                                  arguments => [ $sample, \@ts ],
                                  id        => $sample->{file} );

    }

    last if ($last == $#ids);

}

print "\n[+] Calculating per-base " . ($covonly ? "coverage" : ($mutcount ? "mutation counts" : "RT-stops") . " and coverage") . ". This may take a while...\n\n";

if ($multiBar) {

    $progressBar = Term::Progress::Multiple->new( sets    => { map { $_->{file} => $processmanager->queueSize() / @qcounter } @qcounter },
                                                  colored => 1 ); 
    $progressBar->initAll();

}
else {

    $progressBar = Term::Progress->new( max     => $processmanager->queueSize(),
                                        colored => 1 );
    $progressBar->init();

}

$processmanager->processors(min(ncores(), $threads * $wt));
$processmanager->onstart(sub {});
$processmanager->onexit(sub {});
$processmanager->parentOnExit(sub { 

    # Here we retrieve the partials from each process and combine them
    my ($sample, $pid, $uid, $stats);
    ($sample, $pid, $uid) = @_[0..2];
    $stats = ($processmanager->dequeue($uid)->exitcode())[0];
    
    if (ref($stats) eq "HASH") {

        $progressBar->update($multiBar ? $sample : 1) if (!defined $stats->{error});

        if (defined $stats->{error} || defined $stats->{warning}) { 
            
            my $errMsg = $stats->{error} || $stats->{warning};
            $progressBar->appendText($multiBar ? ($sample, $errMsg) : $errMsg);
            
            if (defined $stats->{error}) {

                $allStats{$sample}->{error} = $errMsg;
                $processmanager->deleteQueue($sample);
                $processmanager->killById($sample);

            }

        }
        else {

            $allStats{$sample}->{$_} += $stats->{$_} for (qw(A C G T mutated total totalPrimary));
            $allStats{$sample}->{covered} += scalar(@{$stats->{ids}});
            
            if (defined $whitelist && $stats->{medianCov} >= $whitelist) {

                my $wlIO = Data::IO->new( file  => $output . "whitelists/" . $sample . ".txt",
                                          mode  => "w+",
                                          flush => 1 );
                $wlIO->write("$_\n") for (@{$stats->{ids}});

            }

            if ($mutcount && $outRawCounts) {

                my $rawIO = Data::IO->new( file  => $output . "raw_counts/" . $sample . ".txt",
                                           mode  => "w+",
                                           flush => 1 );

                for my $i (0 .. $#{$stats->{ids}}) {

                    $rawIO->write($stats->{ids}->[$i] . "\n" .
                                  join("\n", map { join("\t", $_, join(",", @{$stats->{rawCounts}->[$i]->{$_}})) } @mutClasses) . "\n\n");

                }

            }

            if ($mutcount && $onlyMut) { $allFreqs{$sample}->{$_}->{count} += $stats->{onlyMut}->{$_}->{count} for (keys %{$stats->{onlyMut}}); }

        }

    }

});

$processmanager->start();
$processmanager->waitall();

print "\n";

if ($mutmap) {

    print "\n[+] Re-assembling partial MM files...";

    $processmanager->parentOnExit(sub {});

    foreach my $sample (keys %allStats) {

        $processmanager->enqueue( command      => \&reassembleMM,
                                  arguments    => [ $sample ],
                                  id           => $sample );

    }

    $processmanager->start();
    $processmanager->waitall();

    print "\n[+] Indexing MM files...";

    foreach my $sample (keys %allStats) {

        $processmanager->enqueue( command      => \&indexMM,
                                  arguments    => [ $sample ],
                                  id           => $sample );

    }

    $processmanager->start();
    $processmanager->waitall();

}

print "\n[+] Statistics:\n";

foreach my $sample (sort keys %allStats) {

    my ($stats);

    if (exists $allStats{$sample}->{error}) { $stats = "  [!] Processing failed for sample \"$sample\" (" . $allStats{$sample}->{error} . ")"; }
    else {

        $stats = "  [*] Sample \"$sample\":" . (" " x $spacer{$sample}) . ($allStats{$sample}->{covered} || 0) . " transcripts covered";

        if (!$covonly) {

            my ($total, $mutReads, %bases);
            $total = sum(map { $allStats{$sample}->{$_} } qw(A C G T));
            $mutReads = sprintf("%.2f", $allStats{$sample}->{mutated} / $allStats{$sample}->{total} * 100) if ($mutcount && $allStats{$sample}->{total});
            %bases = map { $_ => sprintf("%.2f", $allStats{$sample}->{$_} / $total * 100 ) } qw(A C G T);
            $stats .= " [" . join("; ", map { "$_: " . $bases{$_} } qw(A C G T)) . "]" if ($total);
            $stats .= " - " . $allStats{$sample}->{mutated} . "/" . $allStats{$sample}->{total} . " ($mutReads\%) mutated alignments" if ($mutcount && $allStats{$sample}->{total});

            push(@stats, [ $sample, (map { $bases{$_} } qw(A C G T)), $mutReads ]);

        }

        # Updates the read count in the RC file
        $rcio = RF::Data::IO::RC->new( file           => $output . $sample . ".rc",
                                       mode           => "w+",
                                       noPreloadIndex => 1 );
        $rcio->mappedreads($allStats{$sample}->{totalPrimary});
        $rcio->close();

        if ($mutcount && $onlyMut) {

            my ($totMuts, $freqIO);
            $totMuts = sum(map { $allFreqs{$sample}->{$_}->{count} } keys %{$allFreqs{$sample}});
            $freqIO = Data::IO->new( file  => $output . "frequencies/" . $sample . ".txt",
                                     mode  => "w+",
                                     flush => 1 );
            $freqIO->write(join("\n", map { join("\t", $_, $totMuts ? sprintf("%.6f", $allFreqs{$sample}->{$_}->{count} / $totMuts) : "NaN") } sort keys %{$allFreqs{$sample}}) . "\n");

        }

    }

    print "\n$stats";

}

if ($image && @stats) {

    print "\n\n[+] Generating plots...";

    my ($img, $plot);
    $img = Graphics::Image->new( file   => $output . "plots/base_stats.pdf",
                                 width  => min(scalar(@stats), 40),
                                 height => 8,
                                 R      => $R,
                                 tmpdir => $tmpdir );

    $plot = Graphics::Chart::Barplot->new( x             => "sample",
                                           data          => [ map { @$_[1 .. 4] } @stats ],
                                           dataLabels    => { base   => [ (qw(A C G T)) x @stats ],
                                                              sample => [ map { ($_->[0]) x 4 } @stats ] },
                                           fill          => "base",
                                           groupMethod   => "stack",
                                           dataLabelSort => { base => [ qw(T G C A) ]},
                                           legendSort    => [ qw(A C G T) ],
                                           legendColors  => { A => "#24A349",  
                                                              C => "#4687C7", 
                                                              G => "#EDBA1D",
                                                              T => "#A62324" },
                                           yTitle        => "Per-base " . ($mutcount ? "mutations" : "RT-stops") . " (\%)",
                                           xLabelAngle   => 90,
                                           labelTextSize => 8 );
    $img->plot([$plot]);

    if ($mutcount) {

        $img->file($output . "plots/read_mutation_stats.pdf");
        $plot = Graphics::Chart::Barplot->new( x             => "sample",
                                               data          => [ map { $_->[-1] } @stats ],
                                               dataLabels    => { sample => [ map { $_->[0] } @stats ] },
                                               fill          => "sample",
                                               legend        => 0,
                                               legendColors  => { map { $_->[0] => "black" } @stats },
                                               yTitle        => "Mutated reads (\%)",
                                               xLabelAngle   => 90,
                                               labelTextSize => 8 );

        $img->plot([$plot]);

    }

}

print "\n\n[+] Cleaning up temporary files...";

cleanup();

print "\n[+] All done.\n\n";

sub reassembleMM {

    my $sample = shift;

    my $ret = `cat $tmpdir$sample.*.mm > $output$sample.mm`;

    if (!$ret) {

        my $mmIO = RF::Data::IO::MM->new( file => "$output$sample.mm",
                                          mode => "w+" );
        $mmIO->close(); # adds the EOF marker

    }

}

sub indexMM {

    my $sample = shift;

    my $mmIO = RF::Data::IO::MM->new( file => "$output$sample.mm",
                                      index => "$output$sample.mm.mmi",
                                      mode => "r" );
    $mmIO->buildIndex();
    $mmIO->close(); # adds the EOF marker

}

sub count {

    my ($sample, $ids) = @_;

    $seqio->forceReopenFh(); # On fork() filehandle is cloned. With this we close it and reopen it for all children.

    my ($stats, $readsCount,
        $mmIO, $rcIO, $rcEntry, $readsToMaxCov, 
        @lastPos, @counts, @coverage, %last,
        %stats, %rawCounts);
    %stats = ( ids          => [],
               A            => 0,
               C            => 0,
               G            => 0,
               T            => 0,
               mutated      => 0,
               total        => 0,
               totalPrimary => 0,
               medianCov    => [],
               rawCounts    => [],
               onlyMut      => undef,
               warning      => undef );

    $rcIO = RF::Data::IO::RC->new( file  => $output . $sample->{file} . ".rc",
                                   index => $output . "index.rci",
                                   mode  => "w+" );

    $mmIO = RF::Data::IO::MM->new( file       => $tmpdir . $sample->{file} . ".$$.mm",
                                   appendable => 1,
                                   mode       => "w" ) if ($mutmap);

    if (open(my $fh, "-|", "$samtools view $samtoolsParams " . $sample->{path} . " " . join(" ", map { $realid{$_} } @$ids) . " 2>&1")) {

        while (!eof($fh)) {

            my ($row, $clip5, $cov, $ins,
                $id, $editdist, $truelen, @row);
            $row = <$fh>;
            chomp($row);

            if ($row =~ /Could not retrieve index file/) { return({ error => "Error: Missing BAM index" }); }
            elsif ($row =~ /\[main_samview\] (.+)$/) { 
                
                $stats{"warning"} = "Warning: $1";
                
                next;
                
            }

            @row = split(/\t/, $row);

            if (@row < 11 || $row[5] eq "*") {

                $stats{"warning"} = "Warning: Malformed BAM entry (< 11 fields or invalid CIGAR)";
                
                next;

            }

            $id = $row[2];
            $id =~ s/[^\w\.-]/_/g;
            ($clip5, $cov, $truelen, $ins) = parsecigar($row[5]);
            @{$ins} = map { $_ + $row[3] - 1 } @{$ins}; # Adjust insertion relative position to true position
            $editdist = editdist($row) + @{$ins}; # Editing distance is calculated this way so that consecutively deleted/inserted bases are counted only once

            next if ($mutcount && $truelen < ($discardshorter =~ /^median$/i ? $sample->{medianReadLen} : $discardshorter));
            next if ($mutcount && $editdist / $cov > $maxmut);
            next if ($mutcount && median(map { unpack("C*", $_) - 33 } split(//, $row[10])) < $medianqual); # Check median read's quality
            next if ($clip5 && !$mutcount && !$covonly && !$includeclip); # Discard read in RT-count mode, if it has soft/hard clipping at 5'-end
           
            if ($id ne $last{id}) {

                if (defined $last{id}) {

                    if (exists $masks{$last{id}}) {

                        @counts[$_->[0] .. $_->[1]] = (0) x ($_->[1] - $_->[0] + 1) for (@{$masks{$last{id}}});
                        @coverage[$_->[0] .. $_->[1]] = (0) x ($_->[1] - $_->[0] + 1) for (@{$masks{$last{id}}});

                    }

                    my $rcEntry = RF::Data::RC->new( id         => $last{id},
                                                     sequence   => $last{sequence},
                                                     counts     => \@counts,
                                                     coverage   => \@coverage,
                                                     readscount => $readsCount );

                    $rcIO->write($rcEntry);

                    push(@{$stats{ids}}, $last{id});
                    push(@{$stats{medianCov}}, median(@coverage));
                    push(@{$stats{rawCounts}}, \%rawCounts) if ($outRawCounts);

                }

                $last{id} = $id;

                if ($fast) { 
                    
                    $last{sequence} = $transcripts{$id}; 
                    $last{length} = length($last{sequence}); 

                }
                else {

                    my $entry = $seqio->read($row[2]);
                    $entry->unmask();
                    $last{sequence} = $entry->sequence();
                    $last{length} = $transcripts{$id};

                }

                $readsCount = 0;
                $readsToMaxCov = $last{length} < $sample->{medianReadLen} ? $maxcov : round(($last{length} * $maxcov / $sample->{medianReadLen}) / ($last{length} - $sample->{medianReadLen} + 1)) if ($maxcov);
                @lastPos = (0, 0); # position, count
                @counts = (0) x $last{length};
                @coverage = (0) x $last{length};
                %rawCounts = map { $_ => [ (0) x $last{length} ] } @mutClasses if ($outRawCounts);

                $mmIO->append_transcript($last{id}, $last{sequence}) if ($mutmap);

            }

            if ($mutcount || $covonly) {  # Mutations count / Coverage only modes

                my ($start, @covered);
                $start = $row[3] - 1 < 0 ? 0 : $row[3] - 1;

                if ($maxcov) {

                    next if ($last{length} >= $sample->{medianReadLen} &&
                             $start > $last{length} - $sample->{medianReadLen});

                    if ($lastPos[0] == $start && $lastPos[1] == $readsToMaxCov) { next; }
                    elsif ($lastPos[0] < $start) { @lastPos = ($start, 0); }

                }

                unless ($row[1] & 256) {

                    $readsCount++;
                    $stats{totalPrimary}++;

                }

                $stats{total}++;
                @covered = ($row[3] - 1 < 0 ? 0 : $row[3] - 1) ..($row[3] + $cov - 2 > $last{length} - 1 ? $last{length} - 1 : $row[3] + $cov - 2);

                # Parse the MD flag only when edit distance != 0
                if ($mutcount && $row !~ /NM:i:0/) {

                    my ($end, $muts, $rawMuts, $lowQual, $missingMD);
                    $end = $row[3] + $cov - 2 > $last{length} - 1 ? $last{length} - 1 : $row[3] + $cov - 2;
                    ($muts, $rawMuts, $lowQual, $missingMD) = parsemd(\@row, $last{sequence});

                    return({ error => "Error: Missing MD tag, run 'samtools calmd' to fix" }) if ($missingMD);

                    if ($noCovLowQual) { @covered = grep { !exists $lowQual->{$_} } @covered; }

                    @$muts = uniq(@$muts, @{$ins}) if (!$noins);
                    @$muts = rmconsecutive(@$muts) if ($rmconsecutive);
                    @$muts = collapsemutations(@$muts) if ($collapse);

                    if ($outRawCounts) {

                        foreach my $mut (keys %{$rawMuts}) { $rawCounts{$mut}->[$_]++ for (@{$rawMuts->{$mut}}); }
                        $rawCounts{ins}->[$_]++ for (@{$ins});

                    }

                    if (@$muts) {

                        $stats{mutated}++;

                        for (@$muts) {

                            $counts[$_]++;
                            $stats{substr($last{sequence}, $_, 1)}++;

                        }

    		            # Applies mask to reads in MM file
                        if (exists $masks{$row[2]}) {

                            foreach my $mask (@{$masks{$row[2]}}) {

                                @$muts = grep { $_ < $mask->[0] || $_ > $mask->[1] } @$muts;

                                if ($start >= $mask->[0] && $start <= $mask->[1]) { $start = $mask->[1] + 1; }
                                elsif ($end >= $mask->[0] && $end <= $mask->[1]) { $end = $mask->[0] - 1; }

                            }

                        }

                        $mmIO->append_read($start, $end, scalar(@$muts), $muts) if ($mutmap && @$muts);

                    }

                }

                $lastPos[1]++;
                map {$coverage[$_]++} @covered;

            }
            else {  # RT-stops count mode

                $row[3] -= $sample->{trim5} + $clip5 + 2;

                if ($row[3] >= 0) { # Read 5'-end is not before transcript 5'-end

                    $counts[$row[3]]++;
                    $stats{substr($last{sequence}, $row[3], 1)}++;

                }

                map { $coverage[$_]++ } max(0, $row[3]) .. min($last{length} - 1, $row[3] + $cov + $clip5);

                unless ($row[1] & 256) {

                    $readsCount++;
                    $stats{totalPrimary}++;

                }

                $stats{total}++;

            }

        }

        close($fh);

        if (defined $last{id}) {

            if (exists $masks{$last{id}}) {

                @counts[$_->[0] .. $_->[1]] = (0) x ($_->[1] - $_->[0] + 1) for (@{$masks{$last{id}}});
                @coverage[$_->[0] .. $_->[1]] = (0) x ($_->[1] - $_->[0] + 1) for (@{$masks{$last{id}}});

            }

            my $rcEntry = RF::Data::RC->new( id         => $last{id},
                                             sequence   => $last{sequence},
                                             counts     => \@counts,
                                             coverage   => \@coverage,
                                             readscount => $readsCount );

            $rcIO->write($rcEntry);

            push(@{$stats{ids}}, $last{id});
            push(@{$stats{medianCov}}, median(@coverage));
            push(@{$stats{rawCounts}}, \%rawCounts) if ($outRawCounts);

        }
        
        $rcIO->close();
        $mmIO->close() if ($mutmap);

        $stats{onlyMut} = \%onlyMut;

        return(\%stats);

    }
    else { return({ error => "Error: Unable to read file \"" . $sample->{file} . "\"" }); }

}

sub cleanup {

    unlink(glob($tmpdir . "*"));
    
    if (!-s $output . "error.out") { unlink($output . "error.out"); }
    else { print "\n\n  [!] Warning: Execution completed with error(s)/warning(s). Please check the \"${output}/error.out\" file\n"; }

    rmtree($tmpdir);

}

sub guessTypeAndSorting {

    my $file = shift;

    my ($type, $header, $eof, $sorted, 
        $i, $h, @data, %header);
    $i = $h = 0;
    $header = "\x1f\x8b\x08\x04\x00\x00\x00\x00\x00\xff\x06\x00\x42\x43\x02\x00";
    $eof = "\x1f\x8b\x08\x04\x00\x00\x00\x00\x00\xff\x06\x00\x42\x43\x02\x00\x1b\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00";

    open(my $fh, "-|", "$samtools view -h $samtoolsParams $file 2>&1") or die "\n  [!] Error: Unable to open sample \"$file\" ($!)\n\n";
    while (<$fh>) {

        if (substr($_, 0, 1) eq "@") {

            my $tag = substr($_, 1, 2);

            if ($tag eq "SQ") {

                my @row = split "\t";
                $header{(split(":", $row[1]))[1]} = $h;
                $h++;

            }
            elsif ($tag eq "HD") {

                my @row = split "\t";
                $sorted = 1 if ((split(":", $row[1]))[1] eq "coordinate");

            }

        }
        else {

            $i++;
            my @row = split "\t";

            die "  [!] Error: Sample \"$file\" is not a valid SAM/BAM file\n\n" if (/(?:Failed to open file|fail to read the header)/ ||
                                                                                    @row < 12 || !isint($row[1]) || !isdna($row[9]));

            if (@data) {
                
                if ($header{$row[2]} < $header{$data[0]} || ($header{$row[2]} == $header{$data[0]} && $row[3] < $data[1])) {

                    $sorted = 0;

                    last;

                }
                else { $sorted = 1; }

            }

            @data = ($row[2], $row[3]);

        }

        last if ($i == 100);

    }
    close($fh);

    undef(@data);

    open($fh , "<:raw", $file);
    read($fh, $data[0], 16);
    seek($fh, -28, SEEK_END);
    read($fh, $data[1], 28);
    close($fh);

    if ($data[0] eq $header && $data[1] eq $eof) { $type = "BAM"; }
    else { $type = "SAM"; }

    return($type, $sorted);

}

sub parsemd { # SAM MD flag parser

    my ($row, $reference) = @_;

    my ($md, $llen, @pos, @quals,
        %lowQual, %pos, %posMap);
    $llen = $row->[3] - 1;

    return([], {}, [], 1) if (@{$row} < 11);

    for (10 .. $#{$row}) { if ($row->[$_] =~ m/^MD:Z:(.+)$/) { $md = $1; last; } }

    return([], {}, [], 1) if (!defined $md);

    %posMap = ref2read($row);
    @quals = split(//, $row->[10]);
    $md = uc($md);

    while($md =~ m/^(\d+)/) {

        my ($len, $next);
        $len = $1;
        $md =~ s/^$len//;

        while($md =~ m/^(\D)/) {

            $next = $1;

            if ($next eq "^") { # Deletion

                my ($del, $start, $end, $win,
                    $real, $disttodel, %collapsed);

                $md =~ s/^\^//;
                $md =~ m/^([ACGNT]+)/;
                $del = $1;

                if (!$nodel && length($del) <= $maxdel) { # Count unambiguously mapped deletions as mutations

                    my ($before, $after, @truedel);

                    # Extract a window of 20 nt (+/- 10nt) centered on the deletion
                    $start = $len + $llen - 1 >= 9 ? $len + $llen - 1 - 9 : 0;
                    $end = $len + $llen - 1 + length($del) + 10 < length($reference) ? $len + $llen - 1 + length($del) + 10 : length($reference) - 1;
                    $win = substr($reference, $start, $end - $start + 1);
                    $disttodel = $len + $llen >= 10 ? 10 : $len + $llen;
                    $real = substr($reference, $start, $disttodel) . substr($reference, $start + $disttodel + length($del), $end - $start - $disttodel - length($del) + 1);

                    # Slide the deletion along sequence, and build hash table
                    push(@{$collapsed{substr($win, 0, $_) . substr($win, $_ + length($del), length($win) - length($del) - $_)}}, $start + $_ + length($del) - 1) for (0 .. length($win) - length($del));

                    if (@{$collapsed{$real}} > 1) { # Deletion is not unambiguously mapped

                        if (!$noambiguous) {

                            my $truedel = $leftalign ? min(@{$collapsed{$real}}) : max(@{$collapsed{$real}});
                            $before = $truedel - length($del);
                            $after = $truedel + 1;
                            @truedel = $rightdel ? ($truedel) : ($leftdel ? ($before + 1) : ($before + 1 .. $truedel));
                            # if (($evalsurround &&
                            #     ((exists $posMap{$before} && unpack("C*", $quals[$posMap{$before}]) - 33 >= $minqual) || !exists $posMap{$before}) &&
                            #     ((exists $posMap{$after} && unpack("C*", $quals[$posMap{$after}]) - 33 >= $minqual) || !exists $posMap{$after})) ||
                            #     !$evalsurround) { 
                                    
                                push(@pos, @truedel);
                                push(@{$pos{del}}, @truedel) if ($outRawCounts);
                                
                            #}
                            #else { $lowQual{$_} = 1 for (@truedel); }

                        }

                    }
                    else {

                        $before = $collapsed{$real}->[0] - length($del);
                        $after = $collapsed{$real}->[0] + 1;
                        @truedel = $rightdel ? ($collapsed{$real}->[0]) : ($leftdel ? ($before + 1) : ($before + 1 .. $collapsed{$real}->[0]));
                        # if (($evalsurround &&
                        #     ((exists $posMap{$before} && unpack("C*", $quals[$posMap{$before}]) - 33 >= $minqual) || !exists $posMap{$before}) &&
                        #     ((exists $posMap{$after} && unpack("C*", $quals[$posMap{$after}]) - 33 >= $minqual) || !exists $posMap{$after})) ||
                        #     !$evalsurround) {

                        push(@pos, @truedel);
                        push(@{$pos{del}}, @truedel) if ($outRawCounts);

                        # }
                        # else { $lowQual{$_} = 1 for (@truedel); }

                    }

                }

                $len += length($del);
                $md =~ s/^$del//;

            }
            elsif ($next =~ m/^([ACGNT])$/) {

                my $readBase = substr($row->[9], $posMap{$llen + $len}, 1);

                if ($next ne "N" && $readBase ne "N") {

                    # Include the mutation if both the mutated base and the bases immediately surroundinding
                    # have a quality score >= minqual, and the mutated base is not a N in the reference or in the read
                    if (unpack("C*", $quals[$posMap{$llen + $len}]) - 33 >= $minqual &&
                        (($evalsurround &&
                         ((exists $posMap{$llen + $len - 1} && unpack("C*", $quals[$posMap{$llen + $len - 1}]) - 33 >= $minqual) || !exists $posMap{$llen + $len - 1}) &&
                         ((exists $posMap{$llen + $len + 1} && unpack("C*", $quals[$posMap{$llen + $len + 1}]) - 33 >= $minqual) || !exists $posMap{$llen + $len + 1})) ||
                         !$evalsurround) &&
                        (($onlyMut && $onlyMut{$next . $readBase}->{take}) || !$onlyMut)) {

                        push(@pos, $len + $llen);
                        push(@{$pos{$next . $readBase}}, $len + $llen) if ($outRawCounts);

                    }
                    else { $lowQual{$len + $llen} = 1; }

                    $onlyMut{$next . $readBase}->{count}++ if ($onlyMut);

                }

                $md =~ s/^$next//;
                $len++;

            }

        }

        $llen += $len;

    }

    return(\@pos, \%pos, \%lowQual, 0);

}

sub parsecigar {

    my $cigar = shift;

    my ($clip, $cov, $truelen, $last,
        @ins);
    ($clip, $cov, $truelen, $last) = (0, 0, 0, 0);

    while ($cigar =~ m/^(\d+[SH])/) {

        my $clipsh = $1;
        $cigar =~ s/^$clipsh//;
        $clipsh =~ s/[SH]$//;
        $clip += $clipsh;

    }

    $cov = $clip if ($includeclip);

    while($cigar =~ m/^(\d+)([MIDNSHP=X])/) {

        my ($n, $op) = ($1, $2);
        $cov += $n if (($includeclip && $op =~ m/^[DM=XSH]$/) ||
                       (!$includeclip && $op =~ m/^[DM=X]$/));
        $last += $n if ($op =~ m/^[DNM=X]$/);
        $truelen += $n if ($op =~ m/^[MI=X]$/);
        push(@ins, $last - 1) if ($op eq "I"); # Relative position of the inserted nucleotide

        $cigar =~ s/^$n$op//;

    }

    return($clip, $cov, $truelen, \@ins);

}

sub editdist {

    my $row = shift;

    my $dist = 0;

    if ($row =~ m/MD:Z:(\S+)/) {

        my ($md, $del, $mut);
        $md = $1;
        ($del) = $md =~ s/\^(?:N*[ACGT]+|[ACGT]+N*)[ACGTN]*//g; # This is to avoid counting N-only deletions
        ($mut) = $md =~ tr/ACGT/ACGT/;
        $dist = $del + $mut;

    }

    return($dist);

}

# Collapses consecutive mutations toward the 3'-most one
# e.g. collapsemutations(10, 11, 12) = 12
# Distance tollerance between consecutive mutations is set by $maxmutdist (default: 2)
sub collapsemutations {

    my @values = sort {$a <=> $b} uniq(@_);

    return unless(@values);

    for (my $i=0; $i < $#values; $i++) {

        if (abs(diff(@values[$i..$i+1])) <= $maxmutdist) {

            splice(@values, $i, 1);
            $i--;

        }

    }

    return(@values);

}

sub rmconsecutive {

    my @muts = @_;

    return(@muts) if (@muts < 2);

    my ($last, @selected);

    for(my $i = 0; $i < @muts; $i++) {

        next if ($i > 0 && inrange($muts[$i], [$muts[$i - 1], $muts[$i - 1] + $rmconsecutive]));
	    next if ($i < $#muts && inrange($muts[$i], [$muts[$i + 1] - $rmconsecutive, $muts[$i + 1]]));

	    push(@selected, $muts[$i]);

    }

    return(@selected);

}

sub ref2read { # Reference to read relative position

    my $row = shift;

    my ($rpos, $qpos, $cigar, $lastrpos,
        $lastqpos, @ops, %pos, %ops);
    $cigar = $row->[5];
    $rpos = $lastrpos = $row->[3] - 1;
    $qpos = $lastqpos = 0;
    %ops = ( "M" => [1, 1],
             "I" => [1, 0],
             "D" => [0, 1],
             "N" => [0, 1],
             "S" => [1, 0],
             "H" => [0, 0],
             "P" => [0, 0],
             "=" => [1, 1],
             "X" => [1, 1] );

    while($cigar =~ m/^(\d+)([MIDNSHP=X])/) {

        my ($n, $op) = ($1, $2);
        push(@ops, [$n, $op]);
        $cigar =~ s/^$n$op//;

    }

    for (@ops) {

        my ($n, $op) = @{$_};
        next if (!$ops{$op}->[0] &&
                 !$ops{$op}->[1]);

        $qpos += $n if ($ops{$op}->[0]);
        $rpos += $n if ($ops{$op}->[1]);

        if ($ops{$op}->[0] &&
            $ops{$op}->[1]) {

            if (my $diff = $qpos - $lastqpos) { $pos{$lastrpos + $_} = $lastqpos + $_ for (0 .. $diff - 1); }

        }

        $lastqpos = $qpos;
        $lastrpos = $rpos;

    }

    return(%pos);

}

sub help {

    print "\n  [!] Error: Invalid option. Please check the help\n" if ($_[0]);

    die <<HELP;

 RF Count (v$Core::Utils::VERSION)
 RNA Framework [http://www.rnaframework.com]

 Author:  Danny Incarnato (dincarnato[at]rnaframework.com)
 Summary: Calculates per-base RT-stops/mutations and coverage

 Usage:   rf-count [Options] Sample1.sam Sample2.bam ... Samplen.sam

 Options                                          Description
 -p   or --processors              <int>          Number of files to process in parallel (Default: 1)
 -wt  or --working-threads         <int>          Number of working threads to use for each file (Default: 1).
                                                  Note: at least -p <files> * -wt <threads> processors are required.
 -P   or --per-file-progress                      The progress of each individual file is shown as a separate progress bar
                                                  Note: this only works in interactive mode. If output is redirected to file, a single
                                                        progress bar is shown reporting the overall status. Similarly, if the number of
                                                        samples exceedes the number of lines in the terminal, a single progress bar is
                                                        shown.
 -a   or --fast                                   Reference sequences are kept in memory instead of being loaded on the fly
                                                  Note: this can significantly decrease the runtime when processing large sets of 
                                                        transcripts, but increases memory usage
 -o   or --output-dir              <string>       Output directory (Default: rf_count/)
 -ow  or --overwrite                              Overwrites output directory (if the specified path already exists)
 -s   or --samtools                <string>       Path to samtools executable (Default: assumes samtools is in PATH)
 -g   or --img                                    Enables the generation of statistic plots of per-base % mutations/RT-stops and, for MaP
                                                  experiments only, of % mutated reads (requires R)
 -R   or --R-path                  <string>       Path to R executable (Default: assumes R is in PATH)
 -t5  or --trim-5prime             <int>[,<int>]  Comma separated list (no spaces) of values indicating the number of bases trimmed from the
                                                  5'-end of reads in the respective sample SAM/BAM files (Default: 0)
                                                  Note: Values must be provided in the same order as the input files.
                                                        If a single value is specified along with multiple SAM/BAM files, it will
                                                        be used for all files.
                                                        This parameter has no effect when -m (or --count-mutations) is enabled
 -f   or --fasta                   <string>       Path to a FASTA file containing the reference transcripts
                                                  Note: Transcripts in this file must match transcripts in SAM/BAM file headers
 -mf  or --mask-file               <string>       Path to a mask file
 -ndd or --no-discard-duplicates                  Reads marked as PCR/optical duplicates, discarded by default, will be also considered
 -pn  or --primary-only                           Considers only primary alignments (SAM flag != 256)
 -po  or --paired-only                            When processing SAM/BAM files from paired-end experiments, only those reads for which
                                                  both mates are mapped will be considered
 -pp  or --properly-paired                        When processing SAM/BAM files from paired-end experiments, only those reads mapped in a
                                                  proper pair will be considered
 -ic  or --include-clipped                        Include reads that have been soft/hard-clipped at their 5'-end when calculating RT-stops
                                                  Note: The default behavior is to exclude soft/hard-clipped reads.
                                                        When this option is active, the RT-stop position is considered to be the position
                                                        preceding the clipped bases.
                                                        This option has no effect when -m (or --count-mutations) is enabled.
 -mq  or --map-quality                            Minimum mapping quality to consider a read (Default: 10)
 -co  or --coverage-only                          Only calculates per-base coverage (disables RT-stops/mutations count)
 -m   or --count-mutations                        Enables mutations count instead of RT-stops count (for SHAPE-MaP/DMS-MaPseq)

 |
 +- Mutation count mode options
    -orc or --out-raw-counts                       Generates a text file reporting raw (unfiltered) mutation counts, broken down by class
                                                   (single nucleotide mutations, insertions, deletions)
                                                   Note: the reported counts are affected by the -nd, -na, -mq and -md parameters, but not 
                                                         by deletion realignment options
    -om  or --only-mut                <string>     Only the specified mutations will be counted
                                                   Note: mutations must be provided in the form [original]2[mutated]. For example, "A2T" (or "A>T",
                                                         or "A:T") will only count mutation events in which a reference A base has been sequenced as
                                                         a T. IUPAC codes are also accepted. Multiple mutations must be provided as a comma (or semi-colon)
                                                         separated list (e.g. A2T;C:N,G>A). When specified, this parameter automatically disables insertion
                                                         and deletion count
    -ds  or --discard-shorter         <int>        Discards reads shorter than this length (excluding clipped bases, Default: 1)
                                                   Note: when set to "MEDIAN" (case-insensitive), the median read length will be used
    -q   or --min-quality                          Minimum quality score value to consider a mutation (Phred+33, Default: 20)
    -ncl or --no-cov-low-qual                      If a mutated base (or one of the surrounding bases, if -es is specified) does not exceed the -mq minimum
                                                   quality threshold, that base will be considered as non covered
    -es  or --eval-surrounding                     When considering a mutation, also evaluate the quality of surrounding bases (+/- 1nt)
                                                   Note: the quality score threshold set by -q (or --min-quality) also applies to these bases
    -nd  or --no-deletions                         Ignores deletions
    -ni  or --no-insertions                        Ignores insertions
    -na  or --no-ambiguous                         Ignores ambiguously mapped deletions
                                                   Note: The default behavior is to re-align them to their right-most valid position (or to their
                                                         left-most valid position if -la has been specified)
    -la  or --left-align                           Re-aligns ambiguously mapped deletions to their left-most valid position
                                                   Note: by default, ambiguously mapped deletion are re-aligned to their right-most valid position
    -rd  or --right-deletion                       Only the right-most base in a deletion is marked as mutated
    -ld  or --left-deletion                        Only the left-most base in a deletion is marked as mutated
    -md  or --max-deletion-len        <int>        Ignores deletions longer than this number of nucleotides (Default: 10)
    -me  or --max-edit-distance       <float>      Discards reads with editing distance frequency higher than this threshold (0<m<=1, Default: 0.15 [15%])
    -eq  or --median-quality          <int>        Median quality score threshold for discarding low-quality reads (Phred+33, Default: 20)
    -dc  or --discard-consecutive     <int>        Discards consecutive mutations within this distance from eachothers
    -cc  or --collapse-consecutive                 Collapses consecutive mutations/indels toward the 3'-most one
    -mc  or --max-collapse-distance   <int>        Maximum distance between consecutive mutations/indels to allow collapsing (requires -cc, >=0, Default: 2)
    -mv  or --max-coverage            <int>        Downsamples reads to achieve this maximum mean per-base coverage (>=1000, Default: off)
    -mm  or --mutation-map                         Generates a mutation map (MM) file for alternative structure deconvolution with DRACO
    -wl  or --whitelist               <int>        Generates a DRACO-compatible whitelist file, containing the IDs of transcripts with median
                                                   coverage >= to the specified value

HELP

}
